### 位运算

对于一个前端程序员，几乎用不到位运算，所以在位运算方面只能停留在语法层面，再不断的刷题过程中，也见到了各种各样关于位元素的秒用，不断的积累，逐步去强化这方面的缺失吧。

* 异或运算

  * 和命名一样，它的运算规则就是：二进制位上相同的时运算结果为0，不同时运算结果为1.

  * 性质一：x^x = 0 ,这个容易理解，因为x和x的二进制形式上对应的位置的数字上相同的。

  * 性质二：x^0 = x, eg:`0000 1111`^`0000 0000` = `0000 1111` ,每个位置的结果都是取决于x.

  * 性质三：满足结合律和交换律：

    * x ^ y ^ z = x ^ z ^ y = x ^ (z ^y)

    * x ^ y ^ x = x ^ x ^ y = 0 ^ y = y(结合上面的性质)

#### 使用异或:

* [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)`

```tiki wiki
//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 
//
// 说明： 
//
// 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 
//
// 示例 1: 
//
// 输入: [2,2,1]
//输出: 1
// 
//
// 示例 2: 
//
// 输入: [4,1,2,1,2]
//输出: 4 
// Related Topics 位运算 数组 
// 👍 2094 👎 0
```

根据题意我们可以知道数组元素满足：**某个元素只出现一次以外，其余每个元素均出现两次**,那么我可以将数组中元素全部进行异或运算：`x ^ x ^ y ^ y ^ z = z`,最终得到的结果就是只出现一次的数字：

```go
func singleNumber(nums []int) int {
	ans := 0
	for _,num :=range nums{
		ans ^= num
	}
	return ans
}
```

* #### [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

```tex
//给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
//
// 
// 
//
// 
//
// 示例 1： 
//
// 
//输入：nums = [3,0,1]
//输出：2
//解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 
//
// 示例 2： 
//
// 
//输入：nums = [0,1]
//输出：2
//解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 
//
// 示例 3： 
//
// 
//输入：nums = [9,6,4,2,3,5,7,0,1]
//输出：8
//解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 
//
// 示例 4： 
//
// 
//输入：nums = [0]
//输出：1
//解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 
//
// 
//
// 提示： 
//
// 
// n == nums.length 
// 1 <= n <= 104 
// 0 <= nums[i] <= n 
// nums 中的所有数字都 独一无二 
// 
//
// 
//
// 进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 
// Related Topics 位运算 数组 哈希表 数学 排序 
// 👍 490 👎 0
```

nums中的数字是[0,n] - x,nums1 =[0,n]nums 中的元素和nums1中的所有元素异或，得到的值就x.

```go
func missingNumber(nums []int) int {
	// n的值等于nums
	n := len(nums)
	x :=0
	for _,num := range nums{
		x ^= num
	}

	for i:=0;i<=n;i++{
		x ^= i
	}
	return x
}
```
* 与运算

  * 它的运算规则就是：二进制位上都为1时，运算结果为1，否则运算结果位0.

#### 使用与运算

* [318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

```tiki wiki
//给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为
//每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 
//
// 
//
// 示例 1: 
//
// 
//输入: ["abcw","baz","foo","bar","xtfn","abcdef"]
//输出: 16 
//解释: 这两个单词为 "abcw", "xtfn"。 
//
// 示例 2: 
//
// 
//输入: ["a","ab","abc","d","cd","bcd","abcd"]
//输出: 4 
//解释: 这两个单词为 "ab", "cd"。 
//
// 示例 3: 
//
// 
//输入: ["a","aa","aaa","aaaa"]
//输出: 0 
//解释: 不存在这样的两个单词。
// 
//
// 
//
// 提示： 
//
// 
// 2 <= words.length <= 1000 
// 1 <= words[i].length <= 1000 
// words[i] 仅包含小写字母 
// 
// Related Topics 位运算 数组 字符串 
// 👍 296 👎 0
```

  当拿到这个题时，我的第一想法时组合数组中的单词，当两个单词没有共同的字母时，我们计算他们的长度，当结果长度小于当前的长度时，替换结果长度。我们这么做需要遍历(N^2)次的数组，每次遍历过程我们还需要去遍历两个单词,遍历单词的时间复杂度为（`l1* l2`）.当我们这么做时时间复杂度会特别高，所以我们需要更好的方法去判断两个单词有没有重复的字母，我们可以利用位运算来完成。

将单词中的每个字母a-z转成数字0-25，然后将其对应的二进制数`mask`的二进制位上.然后我们使用两个单词的mask做与运算，当`mask1&mask2!=0`,则说明两个单词有相同的字母。

```go
func maxProduct(words []string) (ans int) {
    masks := map[int]int{}
  	// 求每个单词的mask 
    for _, word := range words {
        mask := 0
        for _, ch := range word {
            mask |= 1 << (ch - 'a')
        }
      	// 当两个单词的mask相同时，保留较大长度的mask
      	// meet 和met两个单词的mask相同，所以当一个和其他的单词有重复字母时，另一个也有
      	// 而我们只需要用长度较长的单词去和其他没有重复字母的单词组合
        if len(word) > masks[mask] {
            masks[mask] = len(word)
        }
    }

    for x, lenX := range masks {
        for y, lenY := range masks {
            if x&y == 0 && lenX*lenY > ans {
                ans = lenX * lenY
            }
        }
    }
    return
}
```



  

  

  

  

  

  

  



